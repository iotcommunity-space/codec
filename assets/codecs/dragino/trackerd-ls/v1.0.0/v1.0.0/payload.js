/*
 * TagoIO Decoders - (https://tago.io/)
 * -------------------
 * Generated by     :: tagoio
 * Generated at     :: Tue Dec 12 2023 12:33:13 GMT+0000 (Coordinated Universal Time)
 * Machine          :: fred <linux> - Node.js v20.6.0
 * -------------------
*/

/* eslint-disable unicorn/number-literal-case */ function freqqBandFind(payload1) {
  switch(payload1[3]){
    case 0x01:
        return "EU868";
    case 0x02:
        return "US915";
    case 0x03:
        return "IN865";
    case 0x04:
        return "AU915";
    case 0x05:
        return "KZ865";
    case 0x06:
        return "RU864";
    case 0x07:
        return "AS923";
    case 0x08:
        return "AS923_1";
    case 0x09:
        return "AS923_2";
    case 0x0a:
        return "AS923_3";
}
}
function decodeePort2(payload1) {
const latitude = (payload1[0] << 24 | payload1[1] << 16 | payload1[2] << 8 | payload1[3]) / 1_000_000;
const longitude = (payload1[4] << 24 | payload1[5] << 16 | payload1[6] << 8 | payload1[7]) / 1_000_000;
const location = `${latitude},${longitude}`;
const alarm = payload1[6] & 0x40 ? true : false;
const battery = (payload1[8] & 0x3f) << 8 | payload1[9];
const mod = (payload1[10] & 0xc0) >> 6;
const led_updown = payload1[10] & 0x20 ? "ON" : "OFF";
const humidity = (payload1[11] << 8 | payload1[12]) / 10;
const temperature = (payload1[13] << 8 | payload1[14]) / 10;
return [
    {
        variable: "location",
        value: location,
        location: {
            lat: latitude,
            lng: longitude
        }
    },
    {
        variable: "alarm",
        value: alarm
    },
    {
        variable: "battery",
        value: battery,
        unit: "mV"
    },
    {
        variable: "mode_type",
        value: mod
    },
    {
        variable: "led_activity",
        value: led_updown
    },
    {
        variable: "humidity",
        value: humidity
    },
    {
        variable: "temperature",
        value: temperature
    }
];
}
function decodeePort3(payload1) {
const latitude = (payload1[0] << 24 | payload1[1] << 16 | payload1[2] << 8 | payload1[3]) / 1_000_000;
const longitude = (payload1[4] << 24 | payload1[5] << 16 | payload1[6] << 8 | payload1[7]) / 1_000_000;
const location = `${latitude},${longitude}`;
const alarm = payload1[8] & 0x40 ? true : false;
const battery = (payload1[8] & 0x3f) << 8 | payload1[9];
const mod = (payload1[10] & 0xc0) >> 6;
const led_updown = payload1[10] & 0x20 ? "ON" : "OFF";
return [
    {
        variable: "location",
        value: location,
        location: {
            lat: String(latitude),
            lng: String(longitude)
        }
    },
    {
        variable: "alarm",
        value: alarm
    },
    {
        variable: "battery",
        value: battery,
        unit: "mV"
    },
    {
        variable: "mode_type",
        value: mod
    },
    {
        variable: "led_activity",
        value: led_updown
    }
];
}
function decodeePort4(payload1) {
const latitude = (payload1[0] << 24 | payload1[1] << 16 | payload1[2] << 8 | payload1[3]) / 1_000_000;
const longitude = (payload1[4] << 24 | payload1[5] << 16 | payload1[6] << 8 | payload1[7]) / 1_000_000;
const location = `${latitude},${longitude}`;
const year = payload1[8] << 8 | payload1[9];
const month = payload1[10];
const day = payload1[11];
const hour = payload1[12];
const minute = payload1[13];
const second = payload1[14];
const date = `${("0" + day).slice(-2)}:${("0" + month).slice(-2)}:${year}`;
const time = `${("0" + hour).slice(-2)}:${("0" + minute).slice(-2)}:${("0" + second).slice(-2)}`;
return [
    {
        variable: "location",
        value: location,
        location: {
            lat: latitude,
            lng: longitude
        }
    },
    {
        variable: "date",
        value: date
    },
    {
        variable: "time",
        value: time
    }
];
}
function decodeePort5(payload1) {
const sensor_model = payload1[0] == 0x13 ? "TrackerD" : "";
const firmware_version = `${payload1[1]}.${payload1[2] >> 4}.${payload1[2] >> 8}`;
const frequency_band = freqqBandFind(payload1);
const sub_band = payload1[4] == 0xff ? "NULL" : payload1[4];
const battery = payload1[5] << 8 | payload1[6];
const smod = payload1[7] >> 6 & 0x3f;
let sensor_mode = "NULL";
if (smod == 1) {
    sensor_mode = "GPS";
} else if (smod == 2) {
    sensor_mode = "BLE";
} else if (smod == 3) {
    sensor_mode = "GPS+BLE";
}
const gps_mode = payload1[7] >> 4 & 0x03;
const ble_mod = payload1[7] & 0x0f;
const ack_mode = payload1[8] & 0x04;
const led_activity = payload1[8] >> 1 & 0x01 ? "ON" : "OFF";
const transport_mode = payload1[8] & 0x01;
return [
    {
        variable: "sensor_model",
        value: sensor_model
    },
    {
        variable: "firmware_version",
        value: firmware_version
    },
    {
        variable: "frequency_band",
        value: frequency_band
    },
    {
        variable: "sub_band",
        value: sub_band
    },
    {
        variable: "battery",
        value: battery,
        unit: "mV"
    },
    {
        variable: "sensor_mode",
        value: sensor_mode
    },
    {
        variable: "gps_mode",
        value: gps_mode
    },
    {
        variable: "ble_mod",
        value: ble_mod
    },
    {
        variable: "ack_mode",
        value: ack_mode
    },
    {
        variable: "led_activity",
        value: led_activity
    },
    {
        variable: "transport_mode",
        value: transport_mode
    }
];
}
function decodeePort6(payload1) {
const slicedArray = payload1.slice(0, 16);
const universally_unique_identifier = slicedArray.toString("hex");
const alarm = payload1[30] & 0x40 ? true : false;
const battery = (payload1[30] & 0x3f) << 8 | payload1[31];
const mod = (payload1[32] & 0xc0) >> 6;
const led_updown = payload1[32] & 0x20 ? "ON" : "OFF";
const ibeacon_major = payload1[16] << 24 | payload1[17] << 16 | payload1[18] << 8 | payload1[19];
const ibeacon_minor = payload1[20] << 24 | payload1[21] << 16 | payload1[22] << 8 | payload1[23];
const ibeacon_power = payload1[24] << 8 | payload1[25];
const received_signal_strength_indication = payload1[26] << 24 | payload1[27] << 16 | payload1[28] << 8 | payload1[29];
return [
    {
        variable: "universally_unique_identifier",
        value: universally_unique_identifier
    },
    {
        variable: "ibeacon_major",
        value: ibeacon_major
    },
    {
        variable: "ibeacon_minor",
        value: ibeacon_minor
    },
    {
        variable: "ibeacon_power",
        value: ibeacon_power
    },
    {
        variable: "received_signal_strength_indication",
        value: received_signal_strength_indication
    },
    {
        variable: "alarm",
        value: alarm
    },
    {
        variable: "battery",
        value: battery,
        unit: "mV"
    },
    {
        variable: "mode_type",
        value: mod
    },
    {
        variable: "led_activity",
        value: led_updown
    }
];
}
function decodeePort7(payload1) {
const alarm = payload1[0] & 0x40 ? true : false;
const batV = ((payload1[0] & 0x3f) << 8 | payload1[1]) / 1000;
const mod = payload1[2] & 0xc0;
const Lon = payload1[2] & 0x20;
return [
    {
        variable: "alarm",
        value: alarm
    },
    {
        variable: "battery",
        value: batV,
        unit: "V"
    },
    {
        variable: "mode_type",
        value: mod
    },
    {
        variable: "led_activity",
        value: Lon ? "ON" : "OFF"
    }
];
}
function decodeePort8(payload1) {
const slicedArray = payload1.slice(0, 6);
const service_set_identifier = slicedArray.toString("hex");
const received_signal_strength_indication = payload1[6] << 24 >> 24;
const alarm = payload1[7] & 0x40 ? true : false; //Alarm status
const battery = ((payload1[7] & 0x3f) << 8 | payload1[8]) / 1000; //Battery,units:V
const mod = (payload1[9] & 0xc0) >> 6;
const led_updown = payload1[9] & 0x20 ? "ON" : "OFF"; //LED status for position,uplink and downlink
return [
    {
        variable: "service_set_identifier",
        value: service_set_identifier
    },
    {
        variable: "received_signal_strength_indication",
        value: received_signal_strength_indication
    },
    {
        variable: "alarm",
        value: alarm
    },
    {
        variable: "battery",
        value: battery,
        unit: "mV"
    },
    {
        variable: "mode_type",
        value: mod
    },
    {
        variable: "led_activity",
        value: led_updown
    }
];
}
function trackerdlsDecoder(payload1, port) {
switch(port){
    // Realtime GNSS Positioning + Temperature & Humidity
    case "2":
        if (payload1.length == 15) {
            return decodeePort2(payload1);
        }
        throw new Error("Incorrect hexadecimal payload length in port 2");
    // Realtime GNSS Positioning (Default Mode)
    case "3":
        if (payload1.length == 11) {
            return decodeePort3(payload1);
        }
        throw new Error("Incorrect hexadecimal payload length in port 3");
    // History GNSS Positioning
    case "4":
        if (payload1.length == 15) {
            return decodeePort4(payload1);
        }
        throw new Error("Incorrect hexadecimal payload length in port 4");
    // Device Status
    case "5":
        if (payload1.length == 9) {
            return decodeePort5(payload1);
        }
        throw new Error("Incorrect hexadecimal payload length in port 5");
    // BLE Positioning with Strongest iBeacon
    case "6":
        if (payload1.length == 33) {
            return decodeePort6(payload1);
        }
        throw new Error("Incorrect hexadecimal payload length in port 6");
    // Alarm information status
    case "7":
        if (payload1.length == 3) {
            return decodeePort7(payload1);
        }
        throw new Error("Incorrect hexadecimal payload length in port 7");
    // WiFi Positioning with Strongest WiFi SSID（Since firmware 1.4.1）
    case "8":
        if (payload1.length == 13) {
            return decodeePort8(payload1);
        }
        throw new Error("Incorrect hexadecimal payload length in port 8");
    default:
        throw new Error("Unknown port");
}
}
const trackerdlsPayloadData = payload.find((x)=>x.variable === "payload_raw" || x.variable === "payload" || x.variable === "data");
const trackerdlsPort = payload.find((x)=> x.variable === "fport" || x.variable === "port" || x.variable === "FPort");
if (trackerdlsPayloadData && trackerdlsPort) {
try {
    // Convert the data from Hex to Javascript Buffer.
    const buffer = Buffer.from(trackerdlsPayloadData?.value, "hex");
    const decodedtrackerdPayload = trackerdlsDecoder(buffer, trackerdlsPort?.value);
    const group = String(Date.now());
    payload = payload.concat(decodedtrackerdPayload?.map((x)=>({
            ...x,
            group
        })) ?? []);
} catch (error) {
    // Print the error to the Live Inspector.
    console.error(error);
    // Return the variable parse_error for debugging.
    payload = [
        {
            variable: "parse_error",
            value: error.message
        }
    ];
}
}


//#sourceMappingURL=data:application/json;charset=utf-8;base64,IntcInZlcnNpb25cIjozLFwic291cmNlc1wiOltdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJcIixcImZpbGVcIjpcInN0ZG91dFwifSI=
